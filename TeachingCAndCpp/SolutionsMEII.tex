\documentclass[a4paper,12pt]{article}

%----------------------------------------------------------------------------------------
%	PACKAGES
%----------------------------------------------------------------------------------------
\usepackage{url}
\usepackage{parskip} 	
\usepackage{tabularx}
\RequirePackage{color}
\RequirePackage{graphicx}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[scale=0.9]{geometry}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage{rotating}
\usetikzlibrary{shapes.geometric,arrows}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{listings}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\usepackage{tabularx}
\usepackage{enumitem}
\newcolumntype{C}{>{\centering\arraybackslash}X} 
\usepackage{supertabular}
\usepackage{tabularx}
\newlength{\fullcollw}
\setlength{\fullcollw}{0.47\textwidth}
\usepackage{titlesec}				
\usepackage{multicol}
\usepackage{multirow}
\titleformat{\section}{\large\scshape\raggedright}{}{0em}{}[\titlerule]
\titlespacing{\section}{0pt}{10pt}{10pt}
\usepackage[style=authoryear,sorting=ynt,maxbibnames=2]{biblatex}
\usepackage[unicode,draft=false]{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour}
\addbibresource{citations.bib}
\setlength\bibitemsep{1em}
\usepackage{fontawesome5}

%----------------------------------------------------------------------------------------
%	BEGIN DOCUMENT
%----------------------------------------------------------------------------------------
\begin{document}

\title{C and C++ Programming Assessment 2 Answers}
\maketitle

\newpage
\pagestyle{empty}

\section{C Multiple Choice Answers}

\begin{enumerate}
    \item \textbf{B) 4 bytes}

    A \verb|float| typically occupies 4 bytes on most systems, following the IEEE 754 single-precision format.

    \item \textbf{B) variable\_1}

    C variable names must begin with a letter or underscore and can include letters, digits, and underscores. Option A starts with a digit, C uses a hyphen, and D uses a hash, all invalid.

    \item \textbf{A) 10}

    The post-increment `x++` evaluates to 5 (current value of `x`), then increments `x` to 6. Thus, `5 * 2 = 10` is printed.

    \item \textbf{B) Buffer overflow}

    The string "Hello World" (11 characters + null terminator = 12 bytes) exceeds the `str[10]` capacity, causing a buffer overflow. Assumes `<string.h>` is included.

    \item \textbf{C) for}

    The `for` loop is ideal for arrays of known size, allowing clear index initialization, condition checking, and incrementation.

    \item \textbf{C) Direct assignment of another array}

    Arrays in C cannot be assigned directly (e.g., `arr1 = arr2`). Initialization requires static, dynamic, or element-by-element methods.

    \item \textbf{B) Out-of-bounds access}

    The array `arr[3]` has indices 0 to 2. Accessing `*(ptr + 3)` (index 3) is out of bounds, causing undefined behavior.

    \item \textbf{B) Preserves variable value between function calls}

    A `static` variable inside a function retains its value across calls, unlike automatic variables.

    \item \textbf{B) int (*func)();}

    A function pointer is declared as `int (*func)()`, where `*func` points to a function returning `int` with no parameters.

    \item \textbf{B) Writing to a closed file}

    The file is closed with `fclose(fp)` before `fprintf`, causing undefined behavior when writing to a closed file pointer.
\end{enumerate}

\section{C++ Multiple Choice Answers}

\begin{enumerate}
    \item \textbf{D) internal}

    C++ access specifiers are `public`, `private`, and `protected`. `internal` is not a C++ keyword.

    \item \textbf{A) Missing semicolon after class}

    A class definition requires a semicolon after the closing brace. The code also lacks an access specifier, but the primary syntax error is the missing semicolon.

    \item \textbf{B) Dynamic binding}

    The `virtual` keyword enables dynamic binding, allowing runtime polymorphism via virtual functions.

    \item \textbf{B) Constructors cannot return values}

    Constructors initialize objects and cannot have a return type or return values, even implicitly.

    \item \textbf{B) Deallocates memory on the heap}

    The `delete` operator frees memory allocated on the heap using `new`.

    \item \textbf{A) Out-of-bounds access}

    The array `arr[5]` has indices 0 to 4. Accessing `arr[5]` is out of bounds, causing undefined behavior.

    \item \textbf{B) Creates a copy of an existing object}

    A copy constructor initializes a new object as a copy of an existing object of the same class.

    \item \textbf{B) const}

    A `const` member function, declared with `const` after the function signature, cannot modify the objectâ€™s state.

    \item \textbf{A) Single, Multiple, Multilevel, Hierarchical, Hybrid}

    These are the types of inheritance in C++. Option B refers to access specifiers, not inheritance types.

    \item \textbf{B) Class B}

    Due to the `virtual` function and dynamic binding, the `display` function of the derived class `B` is called via the base class pointer, outputting "Class B".
\end{enumerate}

\section{C Creative Question Answers}

\begin{enumerate}
    \item \textbf{Array Definition and Printing}

    \lstset{language=C}
    \begin{lstlisting}
        int main() {
            int arr[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
            for (int i = 0; i < 10; i++) {
                printf("%d ", arr[i]);
            }
            printf("\n");
            return 0;
        }
    \end{lstlisting}

    Initializes the array and prints all elements to confirm.

    \item \textbf{Binary Search Function}

    \lstset{language=C}
    \begin{lstlisting}
        int binarySearch(int arr[], int size, int value) {
            int left = 0, right = size - 1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (arr[mid] == value) return mid;
                if (arr[mid] < value) left = mid + 1;
                else right = mid - 1;
            }
            return -1;
        }
    \end{lstlisting}

    Implements binary search on a sorted array, returning the index or -1 if not found.

    \item \textbf{Modify main with Binary Search}

    \lstset{language=C}
    \begin{lstlisting}
        int main() {
            int arr[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
            for (int i = 0; i < 10; i++) {
                printf("%d ", arr[i]);
            }
            printf("\nEnter value to search: ");
            int value;
            scanf("%d", &value);
            int result = binarySearch(arr, 10, value);
            if (result != -1)
                printf("Value %d found at index %d\n", value, result);
            else
                printf("Value %d not found\n", value);
            return 0;
        }
    \end{lstlisting}

    Prompts user input, calls `binarySearch`, and prints the result.

    \item \textbf{Find Second Largest}

    \lstset{language=C}
    \begin{lstlisting}
        int findSecondLargest(int arr[], int size) {
            int first = arr[0], second = arr[0];
            for (int i = 1; i < size; i++) {
                if (arr[i] > first) {
                    second = first;
                    first = arr[i];
                } else if (arr[i] > second && arr[i] != first) {
                    second = arr[i];
                }
            }
            return second;
        }
    \end{lstlisting}

    Finds the second largest value, called in `main` to print the result.

    \item \textbf{Calculate Median}

    \lstset{language=C}
    \begin{lstlisting}
        float calculateMedian(int arr[], int size) {
            return (float)(arr[size/2 - 1] + arr[size/2]) / 2;
        }
    \end{lstlisting}

    For an even-sized sorted array, returns the average of the two middle elements.
\end{enumerate}

\section{C++ Creative Question Answers}

\begin{enumerate}
    \item \textbf{Employee Class Definition}

    \lstset{language=C++}
    \begin{lstlisting}
        class Employee {
        private:
            string name;
            float salaries[6];
            int id;
        public:
            Employee(string n, float s[], int i) {
                name = n;
                for (int j = 0; j < 6; j++) salaries[j] = s[j];
                id = i;
            }
        };
    \end{lstlisting}

    Defines the class with private members and a constructor.

    \item \textbf{Calculate Average Salary}

    \lstset{language=C++}
    \begin{lstlisting}
        float calculateAverageSalary() {
            float sum = 0;
            for (int i = 0; i < 6; i++) {
                sum += salaries[i];
            }
            return sum / 6;
        }
    \end{lstlisting}

    Computes and returns the average of the salaries.

    \item \textbf{Is Above Threshold}

    \lstset{language=C++}
    \begin{lstlisting}
        bool isAboveThreshold() {
            return calculateAverageSalary() > 5000;
        }
    \end{lstlisting}

    Returns `true` if the average salary exceeds 5000.

    \item \textbf{Display Info}

    \lstset{language=C++}
    \begin{lstlisting}
        void displayInfo() {
            cout << "Name: " << name << endl;
            cout << "ID: " << id << endl;
            cout << "Salaries: ";
            for (int i = 0; i < 6; i++) {
                cout << salaries[i] << " ";
            }
            cout << endl;
            float avg = calculateAverageSalary();
            cout << "Average Salary: " << fixed << setprecision(2) << avg << endl;
            cout << "Status: " << (isAboveThreshold() ? "Above Threshold" : "Below Threshold") << endl;
        }
    \end{lstlisting}

    Displays all employee details in the specified format.

    \item \textbf{Main Function}

    \lstset{language=C++}
    \begin{lstlisting}
        int main() {
            float salaries1[6] = {4500.0, 4700.0, 4800.0, 4900.0, 5000.0, 5100.0};
            float salaries2[6] = {5500.0, 5600.0, 5700.0, 5800.0, 5900.0, 6000.0};
            Employee emp1("Alice Johnson", salaries1, 201);
            Employee emp2("Bob Wilson", salaries2, 202);
            emp1.displayInfo();
            cout << endl;
            emp2.displayInfo();
            return 0;
        }
    \end{lstlisting}

    Creates two `Employee` objects and calls `displayInfo` to test all functionalities.
\end{enumerate}
\end{document}