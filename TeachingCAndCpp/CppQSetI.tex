\documentclass[a4paper,12pt]{article}

%----------------------------------------------------------------------------------------
%	FONT
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
%	PACKAGES
%----------------------------------------------------------------------------------------
\usepackage{url}
\usepackage{parskip} 	
\usepackage{tabularx}

%other packages for formatting
\RequirePackage{color}
\RequirePackage{graphicx}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[scale=0.9]{geometry}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage{rotating}
\usetikzlibrary{shapes.geometric, arrows}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{listings}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}


%tabularx environment
\usepackage{tabularx}

%for lists within experience section
\usepackage{enumitem}

% centered version of 'X' col. type
\newcolumntype{C}{>{\centering\arraybackslash}X} 

%to prevent spillover of tabular into next pages
\usepackage{supertabular}
\usepackage{tabularx}
\newlength{\fullcollw}
\setlength{\fullcollw}{0.47\textwidth}

%custom \section
\usepackage{titlesec}				
\usepackage{multicol}
\usepackage{multirow}

%CV Sections inspired by: 
%http://stefano.italians.nl/archives/26
\titleformat{\section}{\large\scshape\raggedright}{}{0em}{}[\titlerule]
\titlespacing{\section}{0pt}{10pt}{10pt}

%for publications
\usepackage[style=authoryear,sorting=ynt, maxbibnames=2]{biblatex}

%Setup hyperref package, and colours for links
\usepackage[unicode, draft=false]{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour}
\addbibresource{citations.bib}
\setlength\bibitemsep{1em}

%for social icons
\usepackage{fontawesome5}

%debug page outer frames
%\usepackage{showframe}
%----------------------------------------------------------------------------------------
%	BEGIN DOCUMENT
%----------------------------------------------------------------------------------------
\begin{document}

% non-numbered pages
\pagestyle{empty} 

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------
% Title Page
\begin{titlepage}
    \centering
    \vspace*{2cm}
    \Huge{\textbf{C++ Programming For Absolute Beginners \& Question Set I}} \\[1.5cm]
    \Large{Sahas Talasila} \\[1cm]
    \vfill
    \vfill
\end{titlepage}

% Table of Contents
\tableofcontents
\newpage


\section*{A Short Overview of Syntax Differences between C and C++}

C and C++ share much of their syntax, but there are notable differences. Below, we examine the main distinctions in the areas of variables, types, declarations, and functions. Where relevant, we show code snippets in both C and C++ to highlight differences.

\section{Variables and Types}

\subsection{Basic Types in C and C++}
\begin{itemize}
    \item Both C and C++ have fundamental types such as \texttt{char}, \texttt{int}, \texttt{float}, \texttt{double}, etc.
    \item C++ introduces additional built-in types such as \texttt{bool} (which is not available in C89 or C90). In C, boolean functionality is typically emulated via \texttt{\#include <stdbool.h>} (C99) or using \texttt{int}.
    \item C++ allows the use of references (\texttt{int\&}) which do not exist in C.
\end{itemize}

\subsection{Variable Declarations}

\begin{itemize}
    \item In C89, all variable declarations must typically appear at the start of a block (though C99 relaxed this to allow mixed declarations).
    \item C++ allows declaring variables anywhere in a block, so you can declare them just before using them.
    \item C++ supports default initialization of certain types through constructors in user-defined classes. C does not have constructors or destructors.
\end{itemize}

\subsubsection{Example: Variable Declaration in C (C99 or later)}
\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdbool.h> // to have a bool type in C (C99)

int main(void) {
    bool flag = true; // Using C99's bool
    int i = 0;

    // ...
    return 0;
}
\end{lstlisting}

\subsubsection{Example: Variable Declaration in C++}
\begin{lstlisting}[language=C++]
#include <iostream>

int main() {
    std::bool flag = true; // Native C++ bool
    int i = 0;        // Declaration anywhere

    // ...
    return 0;
}
\end{lstlisting}

\section{Functions}

\subsection{Function Prototypes and Declarations}
\begin{itemize}
    \item In both C and C++, functions must be declared before they are used unless a default implicit declaration is allowed (in older C standards, calling an undeclared function was allowed, but it is considered bad practice).
    \item In C++, function declarations must specify the parameter types exactly. The older style of function declaration in C (K\&R style) is valid C but is not valid C++.
\end{itemize}

\subsection{Function Overloading}
\begin{itemize}
    \item C does not support function overloading: function names must be unique.
    \item C++ supports function overloading, meaning you can have multiple versions of the same function name with different parameter lists.
\end{itemize}

\subsubsection{Example of Function Overloading in C++}
\begin{lstlisting}[language=C++]
#include <iostream>

void printValue(int x) {
    std::std::cout << "Integer: " << x << std::std::endl;
}

void printValue(double x) {
    std::std::cout << "Double: " << x << std::std::endl;
}

int main() {
    printValue(5);      // Calls printValue(int)
    printValue(5.0);    // Calls printValue(double)
    return 0;
}
\end{lstlisting}

\subsection{Default Arguments}
\begin{itemize}
    \item C does not support default arguments in function parameters.
    \item C++ allows default parameters in function declarations.
\end{itemize}

\subsubsection{Example of Default Arguments in C++}
\begin{lstlisting}[language=C++]
#include <iostream>

int add(int a, int b = 5) {
    return a + b;
}

int main() {
    std::cout << add(10) << std::endl;    // Uses default b=5 => prints 15
    std::cout << add(10, 20) << std::endl; // b=20 => prints 30
    return 0;
}
\end{lstlisting}

\section{References vs. Pointers}
\begin{itemize}
    \item C uses pointers for indirect referencing. C++ also uses pointers but introduces the concept of references (\texttt{\&}), which act like aliases for existing variables.
    \item References must be initialised upon declaration in C++ and cannot be reseated (pointed to a different object) afterwards.
\end{itemize}

\subsubsection{Example of Using References in C++}
\begin{lstlisting}[language=C++]
#include <iostream>

void increment(int &ref) {
    ref++;
}

int main() {
    int x = 10;
    increment(x); // x becomes 11
    std::cout << "x = " << x << std::endl;
    return 0;
}
\end{lstlisting}

\section{Summary of Main Differences}

\begin{itemize}
    \item \textbf{Variable Declarations:} 
    \begin{itemize}
        \item C (pre-C99) requires declarations at the start of a block, C++ does not.
        \item C++ supports references and native \texttt{bool}.
    \end{itemize}

    \item \textbf{Types:}
    \begin{itemize}
        \item C++ provides \texttt{bool}, references, classes, and other built-in object-oriented features.
        \item C typically uses \texttt{\#include <stdbool.h>} for boolean or uses \texttt{int}.
    \end{itemize}

    \item \textbf{Function Overloading:}
    \begin{itemize}
        \item Only available in C++.
        \item C requires unique function names.
    \end{itemize}

    \item \textbf{Default Arguments:}
    \begin{itemize}
        \item Only available in C++.
        \item Not supported in C.
    \end{itemize}
\end{itemize}

\hrulefill

\newpage

\section*{Why C++ is Unique Compared to C}

C++ extends C with features that facilitate more complex and flexible programming paradigms. While it retains much of C's syntax and low-level control, it introduces several key concepts that make it unique:

\begin{enumerate}
    \item \textbf{Object-Oriented Programming (OOP):}
    \begin{itemize}
        \item C++ supports classes, inheritance, and polymorphism, enabling developers to encapsulate data and functions within objects. 
        \item OOP mechanisms help structure large codebases and promote code reuse, which is not an inherent feature of C.
    \end{itemize}
    
    \item \textbf{Encapsulation Through Access Specifiers:}
    \begin{itemize}
        \item C++ classes allow developers to control access to data and methods with \texttt{public}, \texttt{protected}, and \texttt{private} sections, enabling safer data management.
        \item C requires manual conventions (e.g., function naming) to mimic encapsulation.
    \end{itemize}
    
    \item \textbf{Function Overloading and Templates:}
    \begin{itemize}
        \item \textbf{Overloading} allows multiple functions with the same name but different signatures.
        \item \textbf{Templates} introduce generic programming, letting you write code that works with any data type while avoiding redundancy.
        \item These features simplify code reuse and readability, whereas C does not natively support such generic constructs or overloading.
    \end{itemize}
    
    \item \textbf{Operator Overloading:}
    \begin{itemize}
        \item C++ allows redefining the meaning of operators (e.g., \texttt{+}, \texttt{==}) for user-defined types.
        \item In C, operators cannot be overloaded, so custom behavior must be emulated through functions.
    \end{itemize}
    
    \item \textbf{RAII (Resource Acquisition Is Initialization):}
    \begin{itemize}
        \item In C++, resources (memory, file handles, etc.) are typically acquired and released by constructing and destroying objects.
        \item This leads to safer and more intuitive resource management as objects automatically release resources when they go out of scope.
        \item In C, the programmer often manually handles \texttt{malloc} / \texttt{free}, and errors can lead to memory leaks.
    \end{itemize}
    
    \item \textbf{Standard Template Library (STL):}
    \begin{itemize}
        \item C++ comes with a rich set of template-based containers (e.g., \texttt{std::vector}, \texttt{std::map}, \texttt{std::list}) and algorithms.
        \item The STL reduces the need to write custom data structures and algorithms from scratch.
        \item C does not provide a comparable standard library for higher-level containers and algorithms.
    \end{itemize}
    
    \item \textbf{Exception Handling:}
    \begin{itemize}
        \item C++ provides structured exceptions with \texttt{try}, \texttt{throw}, and \texttt{catch}, enabling error handling without constant status code checks.
        \item C typically relies on return values and global error variables like \texttt{errno}.
    \end{itemize}
\end{enumerate}

\section*{C++ Examples Showcasing Core Features}

Below are several small C++ programs that demonstrate different aspects of the language, including variable types, operators, loops, and conditional flow. Finally, we provide an example that combines all of these aspects into one program. This should be familiar to you.

\subsection{Different Variable Types}

\begin{lstlisting}[language=C++, caption={Example of different variable types}]
#include <iostream>

int main() {
    int wholeNumber = 42;          // Integer
    double pi = 3.14159;           // Floating-point
    char letter = 'A';             // Character
    bool isCplusplusFun = true;    // Boolean
    float percentage = 99.9f;      // Single-precision float

    std::cout << "Integer: " << wholeNumber << std::endl;
    std::cout << "Double: " << pi << std::endl;
    std::cout << "Char: " << letter << std::endl;
    std::cout << "Bool: " << isCplusplusFun << std::endl;
    std::cout << "Float: " << percentage << '%' << std::endl;

    return 0;
}
\end{lstlisting}

\section{Operators}

\begin{lstlisting}[language=C++, caption={Example showcasing basic operators}]
#include <iostream>

int main() {
    int a = 10;
    int b = 3;

    // Arithmetic Operators
    std::cout << "a + b = " << (a + b) << std::endl;
    std::cout << "a - b = " << (a - b) << std::std::endl;
    std::cout << "a * b = " << (a * b) << std::endl;
    std::cout << "a / b = " << (a / b) << std::endl; // integer division
    std::cout << "a % b = " << (a % b) << std::endl; // modulus

    // Increment / Decrement
    a++; // Post-increment
    std::cout << "After a++: " << a << std::endl;
    ++b; // Pre-increment
    std::cout << "After ++b: " << b << std::endl;

    // Relational and Logical Operators
    std::cout << "Is a > b? " << (a > b) << std::endl;
    std::cout << "Is a == b? " << (a == b) << std::endl;
    std::cout << "Is (a > b) && (b > 5)? " << ((a > b) && (b > 5)) << std::endl;

    return 0;
}
\end{lstlisting}

\section{Loops}

\begin{lstlisting}[language=C++, caption={Examples of different loop constructs}]
#include <iostream>

int main() {
    // For loop
    std::cout << "For loop example:" << std::endl;
    for (int i = 0; i < 5; i++) {
        std::cout << "i = " << i << std::endl;
    }

    // While loop
    std::cout << "\nWhile loop example:" << std::endl;
    int count = 0;
    while (count < 3) {
        std::cout << "count = " << count << std::endl;
        count++;
    }

    // Do-while loop
    std::cout << "\nDo-while loop example:" << std::endl;
    int num = 0;
    do {
        std::cout << "num = " << num << std::endl;
        num++;
    } while (num < 2);

    return 0;
}
\end{lstlisting}

\section{Conditional Flow Statements}

\begin{lstlisting}[language=C++, caption={Examples of if/else and switch statements}]
#include <iostream>

int main() {
    int x = 10;

    if (x > 0) {     // if-else statement
        std::cout << "x is positive" << std::endl;
    } else if (x < 0) {
        std::cout << "x is negative" << std::endl;
    } else {
        std::cout << "x is zero" << std::endl;
    }

    char grade = 'B';     // switch statement
    switch (grade) {
        case 'A':
            std::cout << "Excellent!" << std::endl;
            break;
        case 'B':
            std::cout << "Well done" << std::endl;
            break;
        case 'C':
            std::cout << "You passed" << std::endl;
            break;
        default:
            std::cout << "Invalid grade" << std::endl;
    }

    return 0;
}
\end{lstlisting}

\section{Combined Example}

In this final example, we combine variables of different types, operators, loops, and conditionals in a simple interactive program.

\begin{lstlisting}[language=C++, caption={Combined example}]
#include <iostream>
#include <string>

int main() {
    // Variable declarations
    string name;
    int age = 0;
    double sum = 0.0;

    std::cout << "Enter your name: ";
    std::cin >> name;

    std::cout << "Enter your age: ";
    std::cin >> age;

    // Conditional statement
    if (age < 18) {
        std::cout << "Sorry, " << name << ", you are under 18.\n";
    } else {
        std::cout << "Welcome, " << name << "! You are old enough.\n";
    }

    // Loop to add numbers
    std::cout << "\nLet's add 5 numbers:\n";
    for (int i = 1; i <= 5; i++) {
        double value;
        std::cout << "Enter number " << i << ": ";
        std::cin >> value;
        sum += value; // using the + operator
    }

    // Output results using operators
    std::cout << "\nThe total sum of your 5 numbers is: " << sum << std::endl;
    std::cout << "Average of the 5 numbers is: " << (sum / 5) << std::endl;

    // Another conditional section
    if (sum > 50) {
        std::cout << "That's quite a large sum!" << std::endl;
    } else {
        std::cout << "That's a modest sum." << std::endl;
    }

    return 0;
}
\end{lstlisting}

\newpage

\section*{Comparative Example in C and C++}

Below are two short programs that perform similar tasks (printing a boolean variable and calling a function that prints a value). The C program uses \texttt{stdbool.h} for boolean support and only a single function, while the C++ program uses native \texttt{bool} and demonstrates function overloading.

\subsection*{C Version}
\begin{lstlisting}[language=C, caption={C example using stdbool.h and printf}]
#include <stdio.h>
#include <stdbool.h> // Required for bool in C (C99 and later)

void printValueInt(int val) {
    printf("Integer: %d\n", val);
}

int main(void) {
    bool flag = true;  // C99 bool
    printf("Flag is: %d\n", flag); // prints 1 or 0

    // Since C does not support function overloading,
    // we define separate functions for each data type if needed.
    printValueInt(42);

    return 0;
}
\end{lstlisting}

\subsection*{C++ Version}
\begin{lstlisting}[language=C++, caption={C++ example using native bool, function overloading, and iostream}]
#include <iostream>

// Overloaded functions: same name, different parameter types
void printValue(int val) {
    std::cout << "Integer: " << val << std::endl;
}

void printValue(double val) {
    std::cout << "Double: " << val << std::endl;
}

int main() {
    bool flag = true;       // Native C++ bool
    std::cout << "Flag is: " << flag << std::endl; // prints 1 or 0 by default
    
    // In C++, we can overload functions, so the same name works for different types.
    printValue(42);
    printValue(3.14);

    return 0;
}
\end{lstlisting}

\newpage

\subsection*{Key Differences Highlighted}

\begin{itemize}
    \item \textbf{Boolean Support:} 
    \begin{itemize}
        \item In C, \texttt{\#include <stdbool.h>} is needed to use \texttt{bool}, \texttt{true}, and \texttt{false}.
        \item In C++, \texttt{bool} is a built-in type and requires no extra header.
    \end{itemize}

    \item \textbf{Input/Output:}
    \begin{itemize}
        \item The C example uses \texttt{printf} from \texttt{stdio.h}.
        \item The C++ example uses \texttt{std::cout} from \texttt{iomanip} (actually provided by \texttt{iostream}) for output.
    \end{itemize}

    \item \textbf{Function Overloading:}
    \begin{itemize}
        \item C does not allow functions to have the same name with different parameter lists (no overloading).
        \item C++ allows multiple functions with the same name, as long as the parameter signatures differ.
    \end{itemize}
\end{itemize}


\section*{Assessment: Variables, Data Types, and Functions}

\subsection*{Part 1 A: Multiple Choice Questions (10 questions)}
\begin{enumerate}
    \item Which of the following data types is used to store a single character in C/C++?
    \begin{enumerate}
        \item \texttt{int}
        \item \texttt{char}
        \item \texttt{bool}
        \item \texttt{double}
    \end{enumerate}

    \item In C++ (and in C99 with \texttt{stdbool.h}), which keyword represents a boolean type?
    \begin{enumerate}
        \item \texttt{bit}
        \item \texttt{bool}
        \item \texttt{logical}
        \item \texttt{boolean}
    \end{enumerate}

    \item Which of the following statements regarding variable scope is true?
    \begin{enumerate}
        \item Global variables can only be accessed inside one function.
        \item Local variables can be accessed anywhere in the program.
        \item Global variables are accessible by all functions by default.
        \item Static variables cannot be declared inside functions.
    \end{enumerate}

    \item Which operator is used to obtain the memory address of a variable in both C and C++?
    \begin{enumerate}
        \item \texttt{\%}
        \item \texttt{\&}
        \item \texttt{*}
        \item \texttt{\^{}}
    \end{enumerate}

    \item In C++, which of the following allows you to write multiple functions with the same name but different parameter types?
    \begin{enumerate}
        \item Function pointers
        \item Function overloading
        \item Function templates only
        \item Macros
    \end{enumerate}

    \item Which data type is most appropriate for storing a value like 3.14159 in C/C++?
    \begin{enumerate}
        \item \texttt{int}
        \item \texttt{char}
        \item \texttt{float}
        \item \texttt{double}
    \end{enumerate}

    \item Which statement about functions in C/C++ is correct?
    \begin{enumerate}
        \item A function must always return an \texttt{int}.
        \item A function cannot be declared without parameters.
        \item Functions can return any valid data type or \texttt{void}.
        \item Only C++ supports functions with parameters.
    \end{enumerate}

    \item In C, how do you create a constant variable that cannot be modified?
    \begin{enumerate}
        \item Use \texttt{\#define} macro
        \item Use \texttt{static}
        \item Use \texttt{const} keyword before the data type
        \item You cannot create constant variables in C
    \end{enumerate}

    \item Which of the following is the correct way to declare a pointer to an integer in C/C++?
    \begin{enumerate}
        \item \texttt{int ptr*;}
        \item \texttt{int *ptr;}
        \item \texttt{int \&ptr;}
        \item \texttt{pointer int ptr;}
    \end{enumerate}

    \item Which looping construct checks the condition \textit{after} each iteration in C/C++?
    \begin{enumerate}
        \item \texttt{for}
        \item \texttt{while}
        \item \texttt{do-while}
        \item None of the above
    \end{enumerate}
\end{enumerate}

\newpage

\subsection*{Part 1 B: Short Form Questions (10 questions)}
\begin{enumerate}
    \item Define the term \textit{variable declaration} and give one example in C/C++.
    \item What is the primary difference between \texttt{float} and \texttt{double} in terms of precision?
    \item Explain how you would declare and initialize a \texttt{bool} variable in C++.
    \item How do you return a value from a function in C/C++? Provide a brief example.
    \item What keyword is used in C++ to prevent a variable from being modified after initialization?
    \item In C++, what is the purpose of a function prototype?
    \item How would you write a function in C/C++ that does not return any value nor take any parameters?
    \item State one reason why you might use a \texttt{typedef} in C.
    \item Provide an example of a function call with two arguments in C/C++.
    \item Explain what happens if you call a function in C/C++ but do not include its declaration or definition before the call.
\end{enumerate}

\subsection*{Part C: Long Form / Open-Ended Questions (5 questions)}
\begin{enumerate}
    \item Compare and contrast the way C and C++ handle boolean types, including any relevant headers or keywords required in C.
    \item Discuss how local and global variables are stored in memory, highlighting the implications for program design and potential issues (e.g., naming conflicts, memory usage).
    \item Explain the concept of \textit{function overloading} in C++. How is it implemented, and why can it be advantageous compared to having multiple function names?
    \item Describe in detail how function prototypes and definitions work together in a C/C++ program. Include information about header files, forward declarations, and linking.
    \item Suppose you have a function that receives a large array or object as a parameter. Compare the implications of passing it by value, by pointer, and by reference (in C++). Which method would you typically choose for performance or safety reasons, and why?
\end{enumerate}

\newpage

% Enumerating the answers without sections
\begin{enumerate}

\subsubsection{Answers for long form questions}

% Answer 1: Boolean Types Comparison
\item \textbf{Comparison of Boolean Types in C and C++}

\textbf{C Boolean Handling:} Standard C (prior to C99) lacks a native boolean type, so programmers use \texttt{int}, with 0 for false and non-zero (typically 1) for true. Since C99, the \texttt{\_Bool} type, which holds only 0 or 1, is available. Including \texttt{<stdbool.h>} defines \texttt{bool} as a macro for \texttt{\_Bool}, \texttt{true} as 1, and \texttt{false} as 0.

\begin{lstlisting}
#include <stdbool.h>
bool is_valid = true;
if (is_valid) { /* do something */ }
\end{lstlisting}

Without \texttt{<stdbool.h>}, custom boolean definitions (e.g., \texttt{typedef int bool;}) are needed, reducing type safety as \texttt{\_Bool} accepts integer assignments but coerces them to 0 or 1.

\textbf{C++ Boolean Handling:} C++ has a native \texttt{bool} type that holds \texttt{true} or \texttt{false}, requiring no header. It enforces stricter type checking, converting non-zero integers to \texttt{true} and zero to \texttt{false}, but \texttt{bool} is distinct from \texttt{int}.

\begin{lstlisting}
bool is_valid = true;
if (is_valid) { /* do something */ }
\end{lstlisting}

\textbf{Comparison:} C requires \texttt{<stdbool.h>} for \texttt{bool}, while C++ includes it natively. C++’s \texttt{bool} is more type-safe than C’s \texttt{\_Bool}. C code without \texttt{<stdbool.h>} may use inconsistent boolean definitions, affecting portability. Both types typically use 1 byte, though this is implementation-dependent.

\textbf{Implications:} C’s reliance on \texttt{<stdbool.h>} can lead to inconsistencies, while C++’s native \texttt{bool} enhances readability. C’s integer-based booleans are flexible for low-level tasks like bit manipulation.

% Answer 2: Local and Global Variables
\item \textbf{Local and Global Variables: Memory Storage and Implications}

\textbf{Memory Storage:}

\textit{Local Variables:} Allocated on the stack when a function is called, each call creating a new stack frame. They exist only during the function’s execution and are deallocated upon return. Their scope is limited to the declaring block or function.

\begin{lstlisting}
void func() {
    int local = 10; // Stored on stack, destroyed when func returns
}
\end{lstlisting}

\textit{Global Variables:} Stored in the data segment (static storage) at program startup, persisting for the program’s entire duration. They are accessible throughout the program unless restricted by \texttt{static} (file scope).

\begin{lstlisting}
int global = 10; // Stored in data segment, persists until program ends
\end{lstlisting}

\textbf{Implications for Program Design:}

\textit{Global Variables:} Simplify data sharing across functions and maintain persistent state. However, they risk naming conflicts, are hard to debug due to widespread access, and occupy memory throughout execution. Best practice is to minimize their use and employ \texttt{static} for file-scope globals.

\textit{Local Variables:} Enhance encapsulation, reduce conflicts, and are automatically managed. They require parameter passing for data sharing, increasing complexity, and large local arrays or recursion can cause stack overflow. Use them for temporary, function-specific data.

\textbf{Potential Issues:} Global variables with common names may clash across files without \texttt{static} or namespaces (C++). Excessive globals waste memory, while large local variables risk stack overflow. In multithreaded programs, globals need synchronization to avoid race conditions, unlike thread-safe local variables.

% Answer 3: Function Overloading
\item \textbf{Function Overloading in C++}

\textbf{Concept:} Function overloading allows multiple C++ functions to share the same name but differ in parameter lists (number, types, or order). The compiler selects the correct function based on arguments. C does not support this, requiring unique function names.

\textbf{Implementation:} Define functions with the same name but different signatures. Return type alone cannot differentiate them. The compiler uses name mangling to create unique internal names based on parameter types.

\begin{lstlisting}
int add(int a, int b) {
    return a + b;
}
double add(double a, double b) {
    return a + b;
}
int add(int a, int b, int c) {
    return a + b + c;
}
\end{lstlisting}

Calling example:
\begin{lstlisting}
std::cout << add(1, 2) << std::endl;      // Calls int add(int, int)
std::cout << add(1.5, 2.5) << std::endl;  // Calls double add(double, double)
std::cout << add(1, 2, 3) << std::endl;   // Calls int add(int, int, int)
\end{lstlisting}

\textbf{Advantages:} Overloading improves code readability by using intuitive names (e.g., \texttt{add} for different types) instead of multiple names (e.g., \texttt{addInt}, \texttt{addDouble}). It reduces naming complexity, enhances maintainability, and allows consistent interfaces for related operations, making code more user-fristd::endly.

% Answer 4: Function Prototypes and Definitions
\item \textbf{Function Prototypes and Definitions in C/C++}

\textbf{Function Prototypes:} A prototype declares a function’s name, return type, and parameter list without its body, informing the compiler of its signature. It allows functions to be called before their definition.

\begin{lstlisting}
int sum(int a, int b); // Prototype
\end{lstlisting}

\textbf{Function Definitions:} Provide the actual implementation, including the body. They must match the prototype’s signature.

\begin{lstlisting}
int sum(int a, int b) {
    return a + b;
}
\end{lstlisting}

\textbf{Working Together:} Prototypes enable forward declarations, allowing functions to be defined later or in separate files. The compiler checks calls against prototypes for type safety. During linking, the linker resolves calls to definitions.

\textbf{Header Files:} Prototypes are typically placed in header files (\texttt{.h}) to share declarations across multiple source files. The header is included in source files, and definitions are provided in one source file to avoid multiple definition errors.

\begin{lstlisting}
// sum.h
#ifndef SUM_H
#define SUM_H
int sum(int a, int b);
#endif

// sum.c
#include "sum.h"
int sum(int a, int b) {
    return a + b;
}

// main.c
#include "sum.h"
int main() {
    printf("%d\n", sum(3, 4));
    return 0;
}
\end{lstlisting}

\textbf{Forward Declarations:} Prototypes allow functions to call each other regardless of definition order within a file.

\textbf{Linking:} The linker combines object files, resolving function calls to their definitions. Missing definitions cause linker errors.

% Answer 5: Parameter Passing
\item \textbf{Parameter Passing for Large Arrays or Objects}

\textbf{Passing by Value:} Creates a copy of the entire array or object, stored on the stack. For large data, this is slow due to copying overhead and increases stack memory usage. Changes to the copy do not affect the original.

\begin{lstlisting}
void process(std::vector<int> data) { /* Copy made */ }
\end{lstlisting}

\textbf{Passing by Pointer (C/C++):} Passes the memory address, avoiding copying. Only the pointer (typically 4–8 bytes) is copied. Modifications to the data via the pointer affect the original. Null pointers or invalid addresses risk crashes.

\begin{lstlisting}
void process(int *arr, int size) { arr[0] = 10; } // Modifies original
\end{lstlisting}

\textbf{Passing by Reference (C++):} Passes an alias to the original data, avoiding copying. Like pointers, modifications affect the original, but references cannot be null and are syntactically cleaner. Size information is needed for arrays unless using C++ containers.

\begin{lstlisting}
void process(std::vector<int> &data) { data[0] = 10; } // Modifies original
\end{lstlisting}

\textbf{Choice for Performance/Safety:} Passing by reference (C++) is typically preferred for large objects or arrays. It avoids copying (fast), is safer than pointers (no null or invalid address issues), and is readable. For C, passing by pointer is the only option to avoid copying. Use \texttt{const} (e.g., \verb|const std::vector<int> &data|) to prevent unintended modifications, balancing performance and safety.

\end{enumerate}

\newpage

\subsection{Spot The Error}

\begin{enumerate}
    \item Spot the error in this variable initialization:
\begin{lstlisting}
int number = "25";
\end{lstlisting}

    \item Spot the error in this conditional statement:
\begin{lstlisting}
int x = 7;
if (x = 10)
    std::cout << "x is ten";
\end{lstlisting}

    \item Spot the error in the for-loop syntax below:
\begin{lstlisting}
for int i = 0; i < 5; i++)
    std::cout << i << std::endl;
\end{lstlisting}

    \item Spot the error in this main function:
\begin{lstlisting}
main() {
    std::cout << "Hello!";
    return 0;
}
\end{lstlisting}

    \item Spot the error in using uninitialised variables:
\begin{lstlisting}
int a;
int result = a + 2;
\end{lstlisting}

    \item Spot the error in this function declaration:
\begin{lstlisting}
int max(a, b) {
    return (a > b) ? a : b;
}
\end{lstlisting}

    \item Spot the error related to scope:
\begin{lstlisting}
std::cout << total << std::endl;
int total = 50;
\end{lstlisting}

\end{enumerate}

\end{document}